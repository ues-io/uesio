package oauth2

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"net/url"

	"golang.org/x/oauth2"

	"github.com/thecloudmasters/uesio/pkg/datasource"
	httpClient "github.com/thecloudmasters/uesio/pkg/http"
	"github.com/thecloudmasters/uesio/pkg/meta"
	"github.com/thecloudmasters/uesio/pkg/types/exceptions"
	"github.com/thecloudmasters/uesio/pkg/types/wire"
)

type CredentialAccessors struct {
	Fetch  CredentialFetcher
	Save   CredentialSaver
	Delete CredentialSaver
}
type CredentialFetcher func(ic *wire.IntegrationConnection) (*wire.Item, error)
type CredentialSaver func(credential *wire.Item, ic *wire.IntegrationConnection) error
type authHeaderEventListener func(token *oauth2.Token, authHeader string)

var (
	credentialAccessors *CredentialAccessors
)

func SetUserCredentialAccessors(accessors *CredentialAccessors) {
	credentialAccessors = accessors
}

func defaultCredentialFetch(ic *wire.IntegrationConnection) (*wire.Item, error) {
	session := ic.GetSession()
	connection := ic.GetPlatformConnection()
	coreSession, err := datasource.EnterVersionContext("uesio/core", session, connection)
	if err != nil {
		return nil, errors.New("failed to enter uesio/core context: " + err.Error())
	}
	return GetIntegrationCredential(session.GetSiteUser().ID, ic.GetIntegration().GetKey(), coreSession, connection)
}

func defaultCredentialSave(credential *wire.Item, ic *wire.IntegrationConnection) error {
	connection := ic.GetPlatformConnection()
	coreSession, err := datasource.EnterVersionContext("uesio/core", ic.GetSession(), connection)
	if err != nil {
		return errors.New("failed to enter uesio/core context: " + err.Error())
	}
	return UpsertIntegrationCredential(credential, coreSession, connection)
}

func defaultCredentialDelete(credential *wire.Item, ic *wire.IntegrationConnection) error {
	connection := ic.GetPlatformConnection()
	coreSession, err := datasource.EnterVersionContext("uesio/core", ic.GetSession(), connection)
	if err != nil {
		return errors.New("failed to enter uesio/core context: " + err.Error())
	}
	return DeleteIntegrationCredential(credential, coreSession, connection)
}

func InitCredentialAccessors() {
	credentialAccessors = &CredentialAccessors{
		Fetch:  defaultCredentialFetch,
		Save:   defaultCredentialSave,
		Delete: defaultCredentialDelete,
	}
}

func init() {
	InitCredentialAccessors()
}

func MakeRequestWithStoredUserCredentials(req *http.Request, ic *wire.IntegrationConnection) (*http.Response, error) {
	session := ic.GetSession()
	integration := ic.GetIntegration()
	credentials := ic.GetCredentials()
	// Fetch OAuth credentials from the DB Integration Collection record,
	isAuthCodeFlow := integration.Authentication == "OAUTH2_AUTHORIZATION_CODE"
	integrationCredential, err := credentialAccessors.Fetch(ic)
	if err != nil {
		return nil, errors.New("unable to retrieve integration credential: " + err.Error())
	}
	// If we do NOT have an existing record...
	if integrationCredential == nil {
		// If this is the Authorization Code flow, then we cannot authenticate, we must have an existing access token
		// or a refresh token present on an existing record
		if isAuthCodeFlow {
			return nil, exceptions.NewUnauthorizedException("user has not yet authorized this integration")
		}
		// If this is the Client Credentials flow, it's very likely we don't have an integration credential yet,
		// so we'll need to create one
		integrationCredential = BuildIntegrationCredential(integration.GetKey(), ic.GetSession().GetContextUser().ID, nil)
	}
	tok := GetTokenFromCredential(integrationCredential)
	accessToken := tok.AccessToken
	tokenTypeOverride := credentials.GetEntry("tokenType", "")

	var finalToken *oauth2.Token

	clientOptions := &ClientOptions{
		OnAuthHeaderSet: func(useToken *oauth2.Token, authHeader string) {
			finalToken = useToken
		},
		TokenTypeOverride: tokenTypeOverride,
	}

	client, err := getClient(ic.Context(), integration, credentials, tok, session.GetContextSite().GetHost(), clientOptions)
	if err != nil {
		return nil, err
	}

	httpResp, err := client.Do(req)

	// If the status code is unauthorized, then we need to get a new access token.
	// Retry the request without the access token, just once.
	// This shouldn't happen if the access token expiration is reliable,
	// but that's not the case for many OAuth implementations
	if err == nil && httpResp != nil && httpResp.StatusCode == http.StatusUnauthorized {
		slog.Info("GOT unauthorized response, clearing access token to force re-authenticate...")
		tok.AccessToken = ""
		httpResp, err = client.Do(req)
	}

	if err == nil {
		// See if a new authorization token was generated by the exchange. If so, save this so that subsequent requests use it
		if finalToken != nil && finalToken != tok {
			if finalToken.AccessToken != accessToken {
				slog.Info("GOT new AccessToken, SAVING to DB...")
				PopulateCredentialFieldsFromToken(integrationCredential, finalToken)
				if upsertErr := credentialAccessors.Save(integrationCredential, ic); upsertErr != nil {
					slog.Error("error upserting integration credential: " + upsertErr.Error())
				}
			}
		}
		return httpResp, nil
	}

	// Otherwise, we may need to reauthenticate
	switch typedErr := err.(type) {
	case *url.Error:
		switch innerErr := typedErr.Err.(type) {
		case *oauth2.RetrieveError:
			// This usually means that the refresh token is invalid, expired, or can't be obtained.
			// Delete it, or at least attempt to
			if isAuthCodeFlow {
				slog.Info("Refresh token must be invalid/expired, so we are purging it...")
				if deleteErr := credentialAccessors.Delete(integrationCredential, ic); deleteErr != nil {
					slog.Error("unable to delete integration credential record: " + deleteErr.Error())
				}
			}
			return nil, exceptions.NewUnauthorizedException(innerErr.Error())
		}
	}
	return nil, exceptions.NewUnauthorizedException("Authentication failed: " + err.Error())
}

// getClient creates a custom HTTP client which performs automatic token refreshing on expiration
// while allowing for us (Uesio) to modify how the authorization header is set,
// and notify other code when the header is set to know whether a new access token / refresh token was generated
func getClient(ctx context.Context, integration *meta.Integration, credentials *wire.Credentials, t *oauth2.Token, host string, opts *ClientOptions) (*http.Client, error) {

	var tokenSource oauth2.TokenSource

	if integration.Authentication == "OAUTH2_CLIENT_CREDENTIALS" {
		config, err := GetClientCredentialsConfig(credentials)
		if err != nil {
			return nil, exceptions.NewUnauthorizedException(err.Error())
		}
		tokenSource = oauth2.ReuseTokenSource(t, config.TokenSource(ctx))
	} else if integration.Authentication == "OAUTH2_AUTHORIZATION_CODE" {
		config, err := GetConfig(credentials, host)
		if err != nil {
			return nil, exceptions.NewUnauthorizedException(err.Error())
		}
		tokenSource = config.TokenSource(ctx, t)
	} else {
		return nil, exceptions.NewUnauthorizedException("unsupported OAuth 2 grant type")
	}

	return &http.Client{
		Transport: &Transport{
			Source:        tokenSource,
			Base:          httpClient.Get().Transport,
			ClientOptions: opts,
		},
	}, nil
}

type ClientOptions struct {
	// OnAuthHeaderSet is invoked when the authorization header is set during transport
	OnAuthHeaderSet authHeaderEventListener
	// TokenTypeOverride is used when the retrieved token does not specify its type
	TokenTypeOverride string
}
